
//@version=6
indicator("GG Beluga KHST (Presets + NO-TRADE + EarlyFlip + ADX Rising + Frozen TP1/TP2 + Psych Confirm + Alerts)",
     overlay=true, max_lines_count=300, max_labels_count=300)

//====================================================================
// 0) Presets
//====================================================================
grpPreset = "Presets"
preset = input.string("Gold", "Symbol Preset", options=["Gold","US100","US30","FX"], group=grpPreset)
usePresetDefaults = input.bool(true, "Use preset defaults (recommended)", group=grpPreset)

// --- Trend defaults
measBase = switch preset
    "Gold"  => 10.0
    "US100" => 12.0
    "US30"  => 14.0
    => 16.0

procBase = switch preset
    "Gold"  => 0.010
    "US100" => 0.012
    "US30"  => 0.015
    => 0.020

atrLenBase = switch preset
    "Gold"  => 12
    "US100" => 14
    "US30"  => 14
    => 12

factorBase = switch preset
    "Gold"  => 1.60
    "US100" => 1.70
    "US30"  => 1.80
    => 1.50

// --- Risk defaults
entryAtrMultBase = switch preset
    "Gold"  => 0.60
    "US100" => 0.60
    "US30"  => 0.70
    => 0.50

tp1AtrMultBase = switch preset
    "Gold"  => 1.00
    "US100" => 1.00
    "US30"  => 1.10
    => 0.90

tp2AtrMultBase = switch preset
    "Gold"  => 1.70
    "US100" => 1.80
    "US30"  => 2.00
    => 1.50

slAtrMultBase = switch preset
    "Gold"  => 1.20
    "US100" => 1.30
    "US30"  => 1.40
    => 1.10

// --- NO TRADE / ADX defaults
adxMinBase = switch preset
    "Gold"  => 16.0
    "US100" => 18.0
    "US30"  => 18.0
    => 15.0

// --- EarlyFlip defaults
earlyBaseThresh = switch preset
    "Gold"  => 0.10
    "US100" => 0.12
    "US30"  => 0.14
    => 0.08

// --- ADX rising (slope) defaults (per preset)
adxSlopeLenBase = switch preset
    "Gold"  => 6
    "US100" => 7
    "US30"  => 8
    => 6

adxSlopeThreshBase = switch preset
    "Gold"  => 0.25
    "US100" => 0.35
    "US30"  => 0.45
    => 0.25

//====================================================================
// 1) Inputs
//====================================================================
//-------------------- Trend Engine --------------------
grpTrend = "Trend Engine (Kalman Hull Supertrend)"
src       = input.source(close, "Price Source", group=grpTrend)
measNoise = input.float(12.0, "Measurement Noise (Length)", step=1.0, group=grpTrend)
procNoise = input.float(0.01, "Process Noise", step=0.001, group=grpTrend)
atrLenST  = input.int(12, "Supertrend ATR Period", minval=1, group=grpTrend)
factorST  = input.float(1.7, "Supertrend Factor", step=0.01, group=grpTrend)

showTrend = input.bool(true, "Show KHST Trendline", group=grpTrend)
showFlips = input.bool(true, "Show Flip arrows", group=grpTrend)

colLong   = input.color(color.lime, "Up Color", group=grpTrend, inline="c1")
colShort  = input.color(color.red,  "Down Color", group=grpTrend, inline="c1")

// Effective values (preset or manual)
measEff = usePresetDefaults ? measBase   : measNoise
procEff = usePresetDefaults ? procBase   : procNoise
atrLenE = usePresetDefaults ? atrLenBase : atrLenST
facEff  = usePresetDefaults ? factorBase : factorST

//-------------------- Timeframe Alignment --------------------
grpAlign = "Timeframe Alignment"
useAlign  = input.bool(true, "Use TF Alignment gating", group=grpAlign)
tfCount   = input.int(2, "TFs incl current", minval=1, maxval=4, group=grpAlign)
tf2In     = input.timeframe("", "TF2 (blank=auto x2)", group=grpAlign)
tf3In     = input.timeframe("", "TF3 (blank=auto x3)", group=grpAlign)
tf4In     = input.timeframe("", "TF4 (blank=auto x4)", group=grpAlign)
alignGraceBars = input.int(6, "Alignment grace bars after turning YES", minval=0, maxval=50, group=grpAlign)

//-------------------- NO TRADE regime --------------------
grpNT = "NO TRADE Regime"
useNoTrade  = input.bool(true, "Enable NO TRADE regime", group=grpNT)

useATRfloor = input.bool(true, "ATR floor filter", group=grpNT)
atrFloorLen = input.int(14, "ATR length", minval=1, group=grpNT)
atrFloor    = input.float(0.0, "ATR floor (0=off)", step=0.1, group=grpNT)

useTight    = input.bool(true, "Tight range filter", group=grpNT)
tightLen    = input.int(20, "Tight lookback bars", minval=5, group=grpNT)
tightATRMult= input.float(1.2, "Tight if Range <= ATR * mult", step=0.1, group=grpNT)

// Base ADX filter (optional, for NO-TRADE only)
useADXBase  = input.bool(false, "Base ADX filter (NO-TRADE) (optional)", group=grpNT)
adxMin      = input.float(18.0, "ADX minimum", step=0.5, group=grpNT)

//-------------------- ADX Rising Filter (Soft Gate A) --------------------
grpADX = "ADX Rising Filter (Soft gate A - Recommended)"
useADXRising = input.bool(true, "Enable ADX Rising soft gate", group=grpADX)
adxLen       = input.int(14, "DMI length", minval=1, group=grpADX)
adxSmooth    = input.int(14, "ADX smoothing", minval=1, group=grpADX)

adxSlopeLenIn    = input.int(6, "ADX slope length (bars)", minval=1, group=grpADX)
adxSlopeThreshIn = input.float(0.30, "ADX slope threshold", step=0.05, group=grpADX)

adxMinEff        = usePresetDefaults ? adxMinBase         : adxMin
adxSlopeLenEff   = usePresetDefaults ? adxSlopeLenBase    : adxSlopeLenIn
adxSlopeThreshEff= usePresetDefaults ? adxSlopeThreshBase : adxSlopeThreshIn

//-------------------- Early Flip --------------------
grpEF = "Early Flip (Kalman slope acceleration)"
useEarlyFlip  = input.bool(true, "Enable Early Flip confirmation", group=grpEF)
efLookbackATR = input.int(200, "ATR baseline lookback", minval=20, group=grpEF)
efBaseThresh  = input.float(0.12, "Base threshold", step=0.01, group=grpEF)
efAdaptK      = input.float(1.0, "Volatility adaptation (K)", step=0.1, group=grpEF)
efBaseEff     = usePresetDefaults ? earlyBaseThresh : efBaseThresh

//-------------------- Option A: Frozen Levels --------------------
grpA = "Option A: Frozen Entry/TP/SL"
showA        = input.bool(true, "Show Option A (Frozen levels)", group=grpA)

entryMode    = input.string("ATR", "Entry distance mode", options=["ATR","Percent"], group=grpA)
entryAtrMult = input.float(0.6, "Entry ATR mult", step=0.1, group=grpA)
entryPct     = input.float(0.15, "Entry %", step=0.01, group=grpA)

riskMode     = input.string("ATR", "TP/SL mode", options=["ATR","Percent"], group=grpA)
tp1AtrMult   = input.float(1.0, "TP1 ATR mult", step=0.1, group=grpA)
tp2AtrMult   = input.float(1.7, "TP2 ATR mult", step=0.1, group=grpA)
slAtrMult    = input.float(1.2, "SL ATR mult", step=0.1, group=grpA)

tp1Pct       = input.float(0.50, "TP1 %", step=0.05, group=grpA)
tp2Pct       = input.float(0.90, "TP2 %", step=0.05, group=grpA)
slPct        = input.float(0.60, "SL %", step=0.05, group=grpA)

extendBars   = input.int(60, "Extend lines (bars)", minval=10, maxval=500, group=grpA)
staleBars    = input.int(6, "Refreeze if stale (bars)", minval=1, maxval=50, group=grpA)

// preset-effective risk
entryAtrEff = usePresetDefaults ? entryAtrMultBase : entryAtrMult
tp1AtrEff   = usePresetDefaults ? tp1AtrMultBase   : tp1AtrMult
tp2AtrEff   = usePresetDefaults ? tp2AtrMultBase   : tp2AtrMult
slAtrEff    = usePresetDefaults ? slAtrMultBase    : slAtrMult

//-------------------- Option B: Market NOW + Pending Early --------------------
grpB = "Option B: Market NOW + Pending Early"
showB         = input.bool(true, "Show Market NOW arrow", group=grpB)
showBLabel    = input.bool(true, "Show Market NOW label (Entry+TP1+TP2+SL)", group=grpB)
showPending   = input.bool(true, "Show Pending (EarlyFlip) markers", group=grpB)

//-------------------- Psych Confirmation --------------------
grpPC = "Psych Confirmation (Swings)"
showPC        = input.bool(true, "Show swing confirmations (not entries)", group=grpPC)
pcPivotL      = input.int(3, "Pivot left", minval=1, group=grpPC)
pcPivotR      = input.int(3, "Pivot right", minval=1, group=grpPC)
pcCooldownBars= input.int(12, "Cooldown bars", minval=0, group=grpPC)
pcGateOnAlignTradeOK = input.bool(true, "Only when AlignOK & TradeOK", group=grpPC)
pcTrendFilter = input.bool(true, "Filter: SwingHigh only in downtrend, SwingLow only in uptrend", group=grpPC)
pcShowPopupLabel = input.bool(true, "Show tiny popup label at pivot", group=grpPC)
pcSizeOpt     = input.string("tiny", "Marker size", options=["tiny","small","normal"], group=grpPC)
showCooldownViz = input.bool(true, "Cooldown visualization (right-side label)", group=grpPC)

//-------------------- UI --------------------
grpUI = "UI"
labelYOffsetATR = input.float(2.0, "Status label Y offset (ATR)", step=0.25, group=grpUI)
rightLabelX     = input.int(10, "Right label X padding (bars)", minval=5, maxval=200, group=grpUI)
showScaleMarks  = input.bool(true, "Show Entry/TP/SL on price scale", group=grpUI)

//-------------------- Alerts --------------------
grpAL = "Alerts"
enableAlerts = input.bool(true, "Enable alerts (uses alert() messages)", group=grpAL)
alertOnConfirmedClose = input.bool(true, "Fire alerts on bar close only", group=grpAL)

//====================================================================
// 2) Auto TF builder
//====================================================================
f_autoTf(mult) =>
    string out = timeframe.period
    if timeframe.isintraday
        out := str.tostring(timeframe.multiplier * mult)
    else if timeframe.isdaily
        out := str.tostring(timeframe.multiplier * mult) + "D"
    else if timeframe.isweekly
        out := str.tostring(timeframe.multiplier * mult) + "W"
    else if timeframe.ismonthly
        out := str.tostring(timeframe.multiplier * mult) + "M"
    out

tf2Str = (tf2In == "" ? f_autoTf(2) : tf2In)
tf3Str = (tf3In == "" ? f_autoTf(3) : tf3In)
tf4Str = (tf4In == "" ? f_autoTf(4) : tf4In)

//====================================================================
// 3) Kalman + KHMA + Supertrend
//====================================================================
f_kalman(_x, _R, _Q) =>
    var float est = na
    var float err = na
    if na(est)
        est := _x
        err := 1.0
    predEst = est
    predErr = err + _Q
    K = predErr / (predErr + _R)
    est := predEst + K * (_x - predEst)
    err := (1.0 - K) * predErr
    est

f_khma(_src, _len, _proc) =>
    a = f_kalman(_src, _len/2.0, _proc)
    b = f_kalman(_src, _len,     _proc)
    raw = 2.0 * a - b
    f_kalman(raw, math.max(1.0, math.sqrt(_len)), _proc)

f_supertrend(_src, _atrLen, _factor) =>
    atr = ta.atr(_atrLen)
    upper = _src + _factor * atr
    lower = _src - _factor * atr

    var float fUpper = na
    var float fLower = na
    var int   d = 1

    fUpper := na(fUpper[1]) ? upper : ((upper < fUpper[1] or close[1] > fUpper[1]) ? upper : fUpper[1])
    fLower := na(fLower[1]) ? lower : ((lower > fLower[1] or close[1] < fLower[1]) ? lower : fLower[1])

    if na(d[1])
        d := 1
    else
        if d[1] == -1 and close > fUpper[1]
            d := 1
        else if d[1] == 1 and close < fLower[1]
            d := -1
        else
            d := d[1]

    stLine = (d == 1) ? fLower : fUpper
    [d, stLine, atr]

// Main TF
khma = f_khma(src, measEff, procEff)
[dirMain, stLineMain, atrSTMain] = f_supertrend(khma, atrLenE, facEff)

buyFlip  = showFlips and dirMain == 1 and dirMain[1] == -1
sellFlip = showFlips and dirMain == -1 and dirMain[1] == 1

//====================================================================
// 4) Higher TF alignment (dir only)
//====================================================================
f_dir_on_tf() =>
    khTF = f_khma(src, measEff, procEff)
    [dTF, _, _] = f_supertrend(khTF, atrLenE, facEff)
    dTF

dir2 = request.security(syminfo.tickerid, tf2Str, f_dir_on_tf(), barmerge.gaps_off, barmerge.lookahead_off)
dir3 = request.security(syminfo.tickerid, tf3Str, f_dir_on_tf(), barmerge.gaps_off, barmerge.lookahead_off)
dir4 = request.security(syminfo.tickerid, tf4Str, f_dir_on_tf(), barmerge.gaps_off, barmerge.lookahead_off)

aligned = true
if useAlign
    aligned := false
    if tfCount == 1
        aligned := (dirMain != 0)
    else if tfCount == 2
        aligned := (dirMain != 0 and dir2 == dirMain)
    else if tfCount == 3
        aligned := (dirMain != 0 and dir2 == dirMain and dir3 == dirMain)
    else
        aligned := (dirMain != 0 and dir2 == dirMain and dir3 == dirMain and dir4 == dirMain)

alignTurnOn = aligned and not aligned[1]
var int alignOnBar = na
if alignTurnOn
    alignOnBar := bar_index

inGrace = not na(alignOnBar) and (bar_index - alignOnBar <= alignGraceBars)
alignOK = useAlign ? (aligned or inGrace) : true

//====================================================================
// 5) NO TRADE regime + ADX computations
//====================================================================
atrNow = ta.atr(atrFloorLen)

// DMI/ADX computed ONCE (reused)
[pdi, mdi, adxVal] = ta.dmi(adxLen, adxSmooth)

// ATR floor
atrOK = true
if useATRfloor and atrFloor > 0
    atrOK := (atrNow >= atrFloor)

// Tight range
rangeNow = ta.highest(high, tightLen) - ta.lowest(low, tightLen)
tightOK = true
if useTight
    // "tight" means too compressed => NOT OK
    tightOK := (rangeNow > atrNow * tightATRMult)

// Optional base ADX for NO-TRADE
adxBaseOK = true
if useADXBase
    adxBaseOK := (adxVal >= adxMinEff)

noTrade = useNoTrade and (not atrOK or not tightOK or not adxBaseOK)
tradeOK = not noTrade

//====================================================================
// 6) ADX Rising Filter (Soft gate A)
//   Allow if ADX is OK OR ADX slope is rising enough.
//====================================================================
adxSlope = adxVal - adxVal[adxSlopeLenEff]

adxRisingOK = true
if useADXRising
    slopeOK = (not na(adxSlope)) and (adxSlope >= adxSlopeThreshEff)
    levelOK = (adxVal >= adxMinEff)
    adxRisingOK := (levelOK or slopeOK)

//====================================================================
// 7) Volatility-adaptive Early Flip (slope acceleration)
//====================================================================
slope = khma - khma[1]
accel = slope - slope[1]

atrBase = ta.sma(atrNow, efLookbackATR)
volRatio = (atrBase > 0) ? (atrNow / atrBase) : 1.0
accelNorm = accel / math.max(atrNow, syminfo.mintick)

thresh = efBaseEff * (1.0 + (volRatio - 1.0) * efAdaptK)

earlyBuy  = useEarlyFlip and (slope > 0 and slope[1] <= 0) and (accelNorm >  thresh)
earlySell = useEarlyFlip and (slope < 0 and slope[1] >= 0) and (accelNorm < -thresh)

// Pending (heads-up only)
pendingBuy  = showPending and earlyBuy and not buyFlip
pendingSell = showPending and earlySell and not sellFlip

//====================================================================
// 8) Frozen levels (update on flips OR alignment turning on if stale)
//====================================================================
var float frozenEntry = na
var float frozenTP1   = na
var float frozenTP2   = na
var float frozenSL    = na
var int   frozenSide  = 0
var int   frozenBar   = na

stale = na(frozenBar) ? true : (bar_index - frozenBar > staleBars)

f_entry(_side) =>
    entryMode == "ATR" ? (close + _side * atrNow * entryAtrEff) : (close * (1.0 + _side * (entryPct/100.0)))

f_tp(_side, _entry, _tpAtrMult, _tpPct) =>
    riskMode == "ATR" ? (_entry + _side * atrNow * _tpAtrMult) : (_entry * (1.0 + _side * (_tpPct/100.0)))

f_sl(_side, _entry) =>
    riskMode == "ATR" ? (_entry - _side * atrNow * slAtrEff) : (_entry * (1.0 - _side * (slPct/100.0)))

// Freeze on flips
if buyFlip
    frozenSide  := 1
    frozenEntry := f_entry(1)
    frozenTP1   := f_tp(1, frozenEntry, tp1AtrEff, tp1Pct)
    frozenTP2   := f_tp(1, frozenEntry, tp2AtrEff, tp2Pct)
    frozenSL    := f_sl(1, frozenEntry)
    frozenBar   := bar_index

if sellFlip
    frozenSide  := -1
    frozenEntry := f_entry(-1)
    frozenTP1   := f_tp(-1, frozenEntry, tp1AtrEff, tp1Pct)
    frozenTP2   := f_tp(-1, frozenEntry, tp2AtrEff, tp2Pct)
    frozenSL    := f_sl(-1, frozenEntry)
    frozenBar   := bar_index

// Freeze on first alignment YES if stale
if alignTurnOn and stale
    if dirMain == 1
        frozenSide  := 1
        frozenEntry := f_entry(1)
        frozenTP1   := f_tp(1, frozenEntry, tp1AtrEff, tp1Pct)
        frozenTP2   := f_tp(1, frozenEntry, tp2AtrEff, tp2Pct)
        frozenSL    := f_sl(1, frozenEntry)
        frozenBar   := bar_index
    else if dirMain == -1
        frozenSide  := -1
        frozenEntry := f_entry(-1)
        frozenTP1   := f_tp(-1, frozenEntry, tp1AtrEff, tp1Pct)
        frozenTP2   := f_tp(-1, frozenEntry, tp2AtrEff, tp2Pct)
        frozenSL    := f_sl(-1, frozenEntry)
        frozenBar   := bar_index

//====================================================================
// 9) Activation logic (gates)
//====================================================================
activeA = showA and alignOK and tradeOK and adxRisingOK and frozenSide != 0 and not na(frozenEntry)

// Market NOW signals (trend-aligned)
nowLong  = (buyFlip or earlyBuy) and dirMain == 1
nowShort = (sellFlip or earlySell) and dirMain == -1
activeB  = showB and alignOK and tradeOK and adxRisingOK and (nowLong or nowShort)

//====================================================================
// 10) Visuals: trend + flips + pending + NOW
//====================================================================
trendCol = (dirMain == 1) ? colLong : colShort
plot(showTrend ? stLineMain : na, "KHST Trend", color=trendCol, linewidth=2)

plotshape(buyFlip,  title="BUY Flip",  style=shape.triangleup,   location=location.belowbar, color=color.lime, size=size.tiny, text="BUY")
plotshape(sellFlip, title="SELL Flip", style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.tiny, text="SELL")

plotshape(pendingBuy,  title="Pending (Early) BUY",  style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny, text="P")
plotshape(pendingSell, title="Pending (Early) SELL", style=shape.circle, location=location.abovebar, color=color.new(color.red,  0), size=size.tiny, text="P")

plotshape(activeB and nowLong,  title="NOW BUY",  style=shape.arrowup,   location=location.belowbar, color=color.new(color.lime, 0), size=size.small, text="NOW")
plotshape(activeB and nowShort, title="NOW SELL", style=shape.arrowdown, location=location.abovebar, color=color.new(color.red,  0), size=size.small, text="NOW")

//====================================================================
// 11) Option A lines + labels (Frozen, drawn ONLY on last bar)
//====================================================================
f_line_upsert(_l, x1, y1, x2, y2, clr, style, w) =>
    line out = _l
    if na(out)
        out := line.new(x1, y1, x2, y2, xloc=xloc.bar_index, extend=extend.none)
    line.set_xy1(out, x1, y1)
    line.set_xy2(out, x2, y2)
    line.set_color(out, clr)
    line.set_style(out, style)
    line.set_width(out, w)
    out

f_label_upsert(_lb, x, y, txt, txtClr) =>
    label out = _lb
    if na(out)
        out := label.new(x, y, txt, xloc=xloc.bar_index, style=label.style_label_right,
             textcolor=txtClr, color=color.new(color.black, 0))
    label.set_xy(out, x, y)
    label.set_text(out, txt)
    label.set_textcolor(out, txtClr)
    out

var line  lEntry = na
var line  lTP1   = na
var line  lTP2   = na
var line  lSL    = na
var label lbEntry = na
var label lbTP1   = na
var label lbTP2   = na
var label lbSL    = na

colGrey  = color.new(color.gray, 0)
colEntry = color.new(color.aqua, 0)
colTP    = color.new(color.lime, 0)
colSL    = color.new(color.red,  0)

entryClr = activeA ? colEntry : colGrey
tpClr    = activeA ? colTP    : colGrey
slClr    = activeA ? colSL    : colGrey

if barstate.islast and showA and frozenSide != 0 and not na(frozenEntry)
    x1 = bar_index
    x2 = bar_index + extendBars
    xr = bar_index + rightLabelX

    lEntry  := f_line_upsert(lEntry, x1, frozenEntry, x2, frozenEntry, entryClr, line.style_dotted, 2)
    lbEntry := f_label_upsert(lbEntry, xr, frozenEntry, frozenSide == 1 ? "Entry LONG" : "Entry SHORT", entryClr)

    lTP1  := f_line_upsert(lTP1, x1, frozenTP1, x2, frozenTP1, tpClr, line.style_dotted, 1)
    lbTP1 := f_label_upsert(lbTP1, xr, frozenTP1, "TP1", tpClr)

    lTP2  := f_line_upsert(lTP2, x1, frozenTP2, x2, frozenTP2, tpClr, line.style_dotted, 1)
    lbTP2 := f_label_upsert(lbTP2, xr, frozenTP2, "TP2", tpClr)

    lSL  := f_line_upsert(lSL, x1, frozenSL, x2, frozenSL, slClr, line.style_solid, 2)
    lbSL := f_label_upsert(lbSL, xr, frozenSL, "SL", slClr)

// Price-scale highlighting (right panel visibility)
plot(showScaleMarks and activeA ? frozenEntry : na, "Entry (scale)", color=color.new(color.aqua, 100), display=display.price_scale)
plot(showScaleMarks and activeA ? frozenTP1   : na, "TP1 (scale)",   color=color.new(color.lime, 100), display=display.price_scale)
plot(showScaleMarks and activeA ? frozenTP2   : na, "TP2 (scale)",   color=color.new(color.lime, 100), display=display.price_scale)
plot(showScaleMarks and activeA ? frozenSL    : na, "SL (scale)",    color=color.new(color.red,  100), display=display.price_scale)

//====================================================================
// 12) Psych Confirmation (Swing High/Low) + Cooldown + Visualization
//====================================================================
phPC = ta.pivothigh(high, pcPivotL, pcPivotR)
plPC = ta.pivotlow(low,  pcPivotL, pcPivotR)

// cooldown tracking
var int pcLastFireBar = na
pcBarsSince = na(pcLastFireBar) ? 100000 : (bar_index - pcLastFireBar)
pcInCooldown = pcBarsSince < pcCooldownBars
pcReady = not pcInCooldown
pcRemaining = math.max(pcCooldownBars - pcBarsSince, 0)

// gating
pcGate = true
if pcGateOnAlignTradeOK
    pcGate := pcGate and alignOK and tradeOK

pcSwingHigh = showPC and pcGate and pcReady and not na(phPC)
pcSwingLow  = showPC and pcGate and pcReady and not na(plPC)

// optional trend filter: SH only when downtrend, SL only when uptrend
if pcTrendFilter
    pcSwingHigh := pcSwingHigh and (dirMain == -1)
    pcSwingLow  := pcSwingLow  and (dirMain == 1)

// size (const-only) by branching
pcTiny   = pcSizeOpt == "tiny"
pcSmall  = pcSizeOpt == "small"
pcNormal = pcSizeOpt == "normal"

// plot circles at pivot bar via offset (pcPivotR)
plotshape(pcSwingHigh and pcTiny,   title="PC Swing High (tiny)",   style=shape.circle, location=location.abovebar, color=color.new(color.red, 0),  size=size.tiny,   offset=-pcPivotR)
plotshape(pcSwingHigh and pcSmall,  title="PC Swing High (small)",  style=shape.circle, location=location.abovebar, color=color.new(color.red, 0),  size=size.small,  offset=-pcPivotR)
plotshape(pcSwingHigh and pcNormal, title="PC Swing High (normal)", style=shape.circle, location=location.abovebar, color=color.new(color.red, 0),  size=size.normal, offset=-pcPivotR)

plotshape(pcSwingLow and pcTiny,    title="PC Swing Low (tiny)",    style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny,   offset=-pcPivotR)
plotshape(pcSwingLow and pcSmall,   title="PC Swing Low (small)",   style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.small,  offset=-pcPivotR)
plotshape(pcSwingLow and pcNormal,  title="PC Swing Low (normal)",  style=shape.circle, location=location.belowbar, color=color.new(color.lime, 0), size=size.normal, offset=-pcPivotR)

// optional tiny popup label (draw at pivot bar)
if pcShowPopupLabel and (pcSwingHigh or pcSwingLow)
    pivotBar = bar_index - pcPivotR
    py = pcSwingHigh ? phPC : plPC
    ptxt = pcSwingHigh ? "Confirm: Swing High" : "Confirm: Swing Low"
    label.new(pivotBar, py, ptxt, xloc=xloc.bar_index,
        style=pcSwingHigh ? label.style_label_down : label.style_label_up,
        textcolor=color.white, color=color.new(color.black, 0), size=size.tiny)

// set cooldown start when a signal fires
if pcSwingHigh or pcSwingLow
    pcLastFireBar := bar_index

//====================================================================
// 13) Status + Market NOW label + Cooldown viz (last bar only)
//====================================================================
var label lbStatus = na
var label lbNow    = na
var label lbCD     = na

if barstate.islast
    if not na(lbStatus)
        label.delete(lbStatus)
    if not na(lbNow)
        label.delete(lbNow)
    if not na(lbCD)
        label.delete(lbCD)

    regimeTxt = noTrade ? "NO TRADE" : "TRADE OK"
    alignTxt  = alignOK ? "YES" : "NO"
    adxTxt    = useADXRising ? ("ADXgate: " + (adxRisingOK ? "OK" : "WAIT")) : "ADXgate: OFF"
    txt = "Preset: " + preset + " | Align: " + alignTxt + " | Regime: " + regimeTxt + " | " + adxTxt

    yStatus = high + atrNow * labelYOffsetATR
    lbStatus := label.new(bar_index, yStatus, txt, xloc=xloc.bar_index, style=label.style_label_left,
         textcolor=(noTrade ? color.orange : color.lime),
         color=color.new(color.black, 0))

    // Cooldown visualization (right-side)
    if showCooldownViz and showPC
        cdTxt = pcReady ? "PC Cooldown: READY" : ("PC Cooldown: " + str.tostring(pcRemaining) + " bars")
        yCD = yStatus - atrNow * 0.85
        lbCD := label.new(bar_index + rightLabelX, yCD, cdTxt, xloc=xloc.bar_index, style=label.style_label_right,
            textcolor=pcReady ? color.lime : color.orange, color=color.new(color.black, 0))

    // Market NOW label
    if showBLabel and activeB
        sideNow = nowLong ? 1 : -1

        nowEntry = close
        nowTP1   = f_tp(sideNow, nowEntry, tp1AtrEff, tp1Pct)
        nowTP2   = f_tp(sideNow, nowEntry, tp2AtrEff, tp2Pct)
        nowSL    = f_sl(sideNow, nowEntry)

        nowTxt = str.format(
             "{0}\nEntry: {1}\nTP1: {2}\nTP2: {3}\nSL : {4}",
             sideNow == 1 ? "NOW LONG" : "NOW SHORT",
             str.tostring(nowEntry, format.mintick),
             str.tostring(nowTP1,  format.mintick),
             str.tostring(nowTP2,  format.mintick),
             str.tostring(nowSL,   format.mintick)
        )

        yNow = yStatus - atrNow * 0.9
        lbNow := label.new(bar_index, yNow, nowTxt, xloc=xloc.bar_index, style=label.style_label_left,
             textcolor=color.white, color=color.new(color.black, 0))

//====================================================================
// 14) Alerts (dynamic messages with Entry/TP1/TP2/SL)
//     Create alert in TradingView: "Any alert() function call"
//====================================================================
f_msg(_kind, _side, _entry, _tp1, _tp2, _sl) =>
    (
        _kind + " | " + _side +
        "\nPreset: " + preset +
        "\nSymbol: " + syminfo.ticker +
        "\nTF: " + timeframe.period +
        "\nEntry: " + str.tostring(_entry, format.mintick) +
        "\nTP1: " + str.tostring(_tp1, format.mintick) +
        "\nTP2: " + str.tostring(_tp2, format.mintick) +
        "\nSL : " + str.tostring(_sl,  format.mintick) +
        "\nAlignOK: " + (alignOK ? "true" : "false") +
        " | TradeOK: " + (tradeOK ? "true" : "false") +
        " | ADXgate: " + (adxRisingOK ? "OK" : "WAIT")
    )

fireOK = alertOnConfirmedClose ? barstate.isconfirmed : true

// Market NOW alert triggers
aNowLong  = enableAlerts and fireOK and activeB and nowLong
aNowShort = enableAlerts and fireOK and activeB and nowShort

// Pending (Early) alert triggers (heads-up)
aPendBuy  = enableAlerts and fireOK and alignOK and tradeOK and adxRisingOK and earlyBuy
aPendSell = enableAlerts and fireOK and alignOK and tradeOK and adxRisingOK and earlySell

if aNowLong
    e = close
    t1 = f_tp( 1, e, tp1AtrEff, tp1Pct)
    t2 = f_tp( 1, e, tp2AtrEff, tp2Pct)
    s  = f_sl( 1, e)
    alert(f_msg("MARKET_NOW", "LONG", e, t1, t2, s), alert.freq_once_per_bar_close)

if aNowShort
    e = close
    t1 = f_tp(-1, e, tp1AtrEff, tp1Pct)
    t2 = f_tp(-1, e, tp2AtrEff, tp2Pct)
    s  = f_sl(-1, e)
    alert(f_msg("MARKET_NOW", "SHORT", e, t1, t2, s), alert.freq_once_per_bar_close)

if aPendBuy
    e = close
    t1 = f_tp( 1, e, tp1AtrEff, tp1Pct)
    t2 = f_tp( 1, e, tp2AtrEff, tp2Pct)
    s  = f_sl( 1, e)
    alert(f_msg("PENDING_EARLY", "BUY", e, t1, t2, s), alert.freq_once_per_bar_close)

if aPendSell
    e = close
    t1 = f_tp(-1, e, tp1AtrEff, tp1Pct)
    t2 = f_tp(-1, e, tp2AtrEff, tp2Pct)
    s  = f_sl(-1, e)
    alert(f_msg("PENDING_EARLY", "SELL", e, t1, t2, s), alert.freq_once_per_bar_close)


